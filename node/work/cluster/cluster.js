// Кластеризация
// Процесс кластеризации представляет собой одну из форм горизонтального масштабирования и позволяет приложениям полноценно использовать все имеющиеся мощности процессора несмотря на однопоточность Node.js.

// Кластеризация - это запуск нескольких экземпляров одного приложения для распределения между ними обработки поступающих запросов.

// Для получения максимальной производительности количество запущенных экземпляров не должно превышать количество ядер процессора. Дополнительные (дочерние) экземпляры создаются основным процессом, являются независимыми самостоятельными серверами и привязываются к тому же порту, где запущен основной процесс. Совокупность основного и дочерних экземпляров называется кластером.

// npm i autocannon -g // Инструмент тестирования HTTP
// autocannon -c 200 -d 20 localhost:8080 // шлет запросы в 200 потоков, в течении 20 секунд
// ===================================================================================
// const http = require('http');
// const pid = process.pid;

// http.createServer((req, res) => {
//     // for(let i = 0; i < 1e7; i++) {};
//     res.end('Hello from node js \n');
// }).listen(8080, console.log(`server started on ${pid}`))
// ===================================================================================
// ===================================================================================
// const cluster = require('cluster');
// const pid = process.pid;
// const cpusCount = require('os').cpus().length;

// // console.log(cpusCount);


// if(cluster.isMaster) {
//     console.log(`Master started on ${pid}`);

//     for(let i = 0; i < cpusCount - 1; i++) {
//         cluster.fork();
//     }
// }

// if(cluster.isWorker) {
//     require('./worker.js')
// }


// ===================================================================================


// Методы и свойства модуля cluster:

// fork() - создает новый экземпляр приложения;

// disconnect() - отключает от кластера все созданные дополнительно экземпляры, параметром принимает callback-функцию, которая будет вызвана, когда все экземпляры будут отключены;

// isMaster - булевое значение, если true - значит текущий процесс является основным; Устревший
// isPrimary булевое значение, если true - значит текущий процесс является основным;

// isWorker - булевое значение, если true - значит текущий процесс является дочерним.

// cluster.workers -  Хэш, в котором хранятся активные рабочие объекты, привязанные к idполю. Позволяет легко перебрать всех рабочих. Он доступен только в основном процессе. Рабочий удаляется cluster.workersпосле того, как рабочий отключился и вышел. Порядок между этими двумя событиями нельзя определить заранее. Однако гарантируется, что удаление из cluster.workers списка произойдет до того, как будет сгенерировано последнее событие 'disconnect'или 'exit'событие.

// ===================================================================================

// Методы и свойства воркера:

// cluster.worker - Ссылка на текущий рабочий объект. Недоступно в основном процессе.

// disconnect() - разрывает IPC канал между основным и текущим дочерним процессами, но сам дочерний процесс не завершается, пока у него будут активные подключения, новых подключений он уже не принимает;

// kill() - завершает дочерний экземпляр, начиная с разрыва канала IPC и заканчивая присвоением статуса завершения процесса, который передается методу kill() аргументом (по умолчанию 0);

// isConnected() - возвращает true, если дочерний процесс связан с главным процессом IPC каналом;

// isDead() - возвращает true, если экземпляр уже завершен

// id - уникальный идентификатор процесса;

// process - экземпляр созданного дочернего процесса;

// exitedAfterDisconnect - булевое значение, если true, то экземпляр был завершен вызовом kill() или disconnect()



// ===================================================================================

// События для мастера и воркера одинаковые

// Event: 'disconnect' инициируется при разрыве IPC канала, предназначенного для обмена данными между процессами;

// Event: 'exit' возникает, когда завершается один из дочерних процессов.

// Event: 'fork' инициируется при создании нового экземпляра приложения, в качестве аргумента callback-функции передается созданный экземпляр;

// Event: 'listening' listening - возникает в момент запуска экземпляра сервера при вызове функции listen(), параметры callback-функции - экземпляр и объект с данными адреса, на котором он запущен;

// Event: 'message' инициируется при отправке одним из дочерних экземпляров сообщения основному процессу (сообщение посылается вызовом у дочернего процесса метода send());

// Event: 'online' После разветвления нового воркера он должен ответить онлайн-сообщением. Когда первичный сервер получает онлайн-сообщение, он генерирует это событие. Разница между 'fork'и 'online'заключается в том, что fork генерируется, когда основной разветвляет воркер, и 'online'генерируется, когда он работает.

// Event: 'setup' Инициируется каждый раз, когда .setupPrimary() вызывается.